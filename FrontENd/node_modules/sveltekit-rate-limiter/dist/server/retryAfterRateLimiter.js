import {} from './stores/index.js';
import { RetryAfterStore } from './stores/retryAfterStore.js';
import { RateLimiter } from './rateLimiter.js';
export class RetryAfterRateLimiter extends RateLimiter {
    retryAfter;
    constructor(options = {}, retryAfterStore) {
        super(options);
        this.retryAfter = retryAfterStore ?? new RetryAfterStore();
    }
    static toSeconds(rateMs) {
        return Math.max(0, Math.floor(rateMs / 1000));
    }
    /**
     * Clear all rate limits.
     */
    async clear() {
        await this.retryAfter.clear();
        return await super.clear();
    }
    /**
     * Check if a request event is rate limited.
     * @param {RequestEvent} event
     * @returns {Promise<limited: boolean, retryAfter: number>} Rate limit status for the event.
     */
    async check(event, extraData) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = await this._isLimited(event, extraData);
        if (!result.limited)
            return { limited: false, retryAfter: 0 };
        if (result.hash === null) {
            return {
                limited: true,
                retryAfter: RetryAfterRateLimiter.toSeconds(result.ttl)
            };
        }
        const retryAfter = RetryAfterRateLimiter.toSeconds((await this.retryAfter.add(result.hash, result.ttl)) - Date.now());
        return { limited: true, retryAfter };
    }
}
