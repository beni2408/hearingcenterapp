import { CookieRateLimiter } from './limiters/cookieRateLimiter.js';
import { IPRateLimiter } from './limiters/ipRateLimiter.js';
import { IPUserAgentRateLimiter } from './limiters/ipUaRateLimiter.js';
import { defaultHashFunction } from './hashFunction.js';
import { TTLStore } from './stores/ttlStore.js';
import {} from './limiters/rateLimiterPlugin.js';
import { TTLTime } from './rate.js';
export class RateLimiter {
    store;
    plugins;
    onLimited;
    hashFunction;
    cookieLimiter;
    async isLimited(event, extraData) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return (await this._isLimited(event, extraData))
            .limited;
    }
    /**
     * Clear all rate limits.
     */
    async clear() {
        return await this.store.clear();
    }
    /**
     * Check if a request event is rate limited.
     * @param {RequestEvent} event
     * @returns {Promise<boolean>} true if request is limited, false otherwise
     */
    async _isLimited(event, extraData) {
        let limited = undefined;
        for (let i = 0; i < this.plugins.length; i++) {
            const plugin = this.plugins[i];
            const rate = plugin.rate;
            const id = await plugin.limiter.hash(event, extraData);
            if (id === false) {
                if (this.onLimited) {
                    const status = await this.onLimited(event, 'rejected');
                    if (status === true)
                        return { limited: false, hash: null, ttl: rate[1] };
                }
                return { limited: true, hash: null, ttl: rate[1] };
            }
            else if (id === null) {
                if (limited === undefined)
                    limited = true;
                continue;
            }
            else {
                limited = false;
            }
            if (!id) {
                throw new Error('Empty hash returned from rate limiter ' + plugin.constructor.name);
            }
            if (id === true) {
                return { limited: false, hash: null, ttl: rate[1] };
            }
            // Add the plugin index to the hash, so it differs between limiters with multiple rates
            const hash = i.toString() + (await this.hashFunction(id));
            const currentRate = await this.store.add(hash, rate[1]);
            if (currentRate > rate[0]) {
                if (this.onLimited) {
                    const status = await this.onLimited(event, 'rate');
                    if (status === true)
                        return { limited: false, hash, ttl: rate[1] };
                }
                return { limited: true, hash, ttl: rate[1] };
            }
        }
        return {
            limited: limited ?? false,
            hash: null,
            ttl: this.plugins[this.plugins.length - 1].rate[1]
        };
    }
    constructor(options = {}) {
        this.onLimited = options.onLimited;
        this.hashFunction = options.hashFunction ?? defaultHashFunction;
        if (!this.hashFunction) {
            throw new Error('No RateLimiter hash function found. Please set one with the hashFunction option.');
        }
        //#region Plugin setup
        function mapPluginRates(limiter) {
            if (!limiter.rate.length)
                throw new Error(`Empty rate for limiter ${limiter.constructor.name}`);
            const pluginRates = (Array.isArray(limiter.rate[0]) ? limiter.rate : [limiter.rate]);
            return pluginRates.map((rate) => ({
                rate: [rate[0], TTLTime(rate[1])],
                limiter
            }));
        }
        this.plugins = (options.plugins ?? []).flatMap(mapPluginRates);
        const IPRates = options.IP ?? options.rates?.IP;
        if (IPRates) {
            this.plugins = this.plugins.concat(mapPluginRates(new IPRateLimiter(IPRates)));
        }
        const IPUARates = options.IPUA ?? options.rates?.IPUA;
        if (IPUARates) {
            this.plugins = this.plugins.concat(mapPluginRates(new IPUserAgentRateLimiter(IPUARates)));
        }
        const cookieRates = options.cookie ?? options.rates?.cookie;
        if (cookieRates) {
            this.plugins = this.plugins.concat(mapPluginRates((this.cookieLimiter = new CookieRateLimiter({
                hashFunction: this.hashFunction,
                ...cookieRates
            }))));
        }
        if (!this.plugins.length) {
            throw new Error('No plugins set for RateLimiter!');
        }
        // Sort plugins by rate, if early cancelling
        this.plugins.sort((a, b) => {
            const diff = a.rate[1] - b.rate[1];
            return diff == 0 ? a.rate[0] - b.rate[0] : diff;
        });
        //#endregion
        const maxTTL = this.plugins.reduce((acc, plugin) => {
            const rate = plugin.rate[1];
            if (rate == 1) {
                console.warn('RateLimiter: The "ms" unit is not reliable due to OS timing issues.');
            }
            return Math.max(rate, acc);
        }, 0);
        this.store = options.store ?? new TTLStore(maxTTL, options.maxItems);
    }
}
